/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Deepak C C (https://sketchfab.com/DeepakCC)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/the-punishment-a-study-of-farnese-hercules-0b36d63fd4e44ab6b59088438d4da441
Title: The Punishment- A study of Farnese Hercules
*/

import { useRef, useEffect, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from '@react-three/fiber';
import { a } from '@react-spring/three';
import * as THREE from 'three';

import mosèScene from '../assets/3d/mosè.glb'

const Mosè = ({ isRotating: initialRotating, setIsRotating, onStageChange = () => {}, ...props }) => {
    const mosèRef = useRef();
    const { gl, viewport, scene } = useThree();
    const { nodes, materials, scene: gltfScene } = useGLTF(mosèScene); // Added materials
    const [currentStage, setCurrentStage] = useState(1);
    const [isRotatingLocal, setIsRotatingLocal] = useState(initialRotating);


    // Add a neutral material
    const neutralMaterial = new THREE.MeshStandardMaterial({
      color: "#d4d4d4",
        roughness: 0.5,
        metalness: 0.2,
    });

    // Add lights to enhance visibility
    useEffect(() => {
      const directionalLight = new THREE.DirectionalLight("#ffffff", 1.2);
      directionalLight.position.set(2, 5, 2);
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight("#ffffff", 0.6);
      scene.add(ambientLight);

      return () => {
        scene.remove(directionalLight, ambientLight);
      };
    }, [scene]);


    const lastX = useRef(0);
    const rotationSpeed = useRef(0);
    const dampingFactor = 0.95;


    const handlePointerDown = (e) => {
        e.stopPropagation();
        e.preventDefault();
        setIsRotatingLocal(true);
         setIsRotating(true);


        const clientX = e.touches ? e.touches[0].clientX : e.clientX;

        lastX.current = clientX;
    };

    const handlePointerUp = (e) => {
        e.stopPropagation();
        e.preventDefault();
        setIsRotatingLocal(false);
        setIsRotating(false);
    };

    const handlePointerMove = (e) => {
        e.stopPropagation();
        e.preventDefault();

        if (isRotatingLocal) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;

            const delta = (clientX - lastX.current) / viewport.width;

            mosèRef.current.rotation.y += delta * 0.01 * Math.PI;
            lastX.current = clientX;
            rotationSpeed.current = delta * 0.01 * Math.PI;
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === "ArrowLeft") {
            if (!isRotatingLocal) setIsRotatingLocal(true);
             setIsRotating(true);
            mosèRef.current.rotation.y += 0.01 * Math.PI;
        } else if (e.key === "ArrowRight") {
            if (!isRotatingLocal) setIsRotatingLocal(true);
             setIsRotating(true);
            mosèRef.current.rotation.y -= 0.01 * Math.PI;
        }
    };

    const handleKeyUp = (e) => {
        if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
            setIsRotatingLocal(false);
            setIsRotating(false)
        }
    };

    const calculateStage = (rotationY) => {
      const normalizedRotation = (rotationY + Math.PI * 2) % (Math.PI * 2);
        if (normalizedRotation < Math.PI / 2) return 1;
        if (normalizedRotation < Math.PI) return 2;
        if (normalizedRotation < (3 * Math.PI) / 2) return 3;
        return 4;
    };

  useFrame(() => {
    if (!isRotatingLocal) {
      rotationSpeed.current *= dampingFactor;

      if (Math.abs(rotationSpeed.current) < 0.001) {
        rotationSpeed.current = 0;
      }

      mosèRef.current.rotation.y += rotationSpeed.current;
    }

    const stage = calculateStage(mosèRef.current.rotation.y);
    setCurrentStage(stage);
      onStageChange(stage);
  });

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    return () => {
        canvas.removeEventListener("pointerdown", handlePointerDown);
        canvas.removeEventListener("pointerup", handlePointerUp);
        canvas.removeEventListener("pointermove", handlePointerMove);
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
    };
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);

  return (
    <a.group ref={mosèRef} {...props} >
      <group rotation={[-Math.PI / 2, 0, 0]} scale={1.17}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Object_6.geometry}
        material={materials['Scene_-_Root']}
      />
      </group>
    </a.group>
  )
}


export default Mosè;